package test;
import core;

union Option[#T] {
	var some #T;
	var none Unit;

	static makeSome(value #T) Option[#T] {
		return new(some = value);
	}

	static makeNone() Option[#T] {
		return new(none = unit);
	}
}

class MinBinaryHeap[#T | #T is Orderable[#T]] {
	var sequence core:Array[#T];

	static makeEmpty() MinBinaryHeap[#T] {
		return new(sequence = core:Array[#T].make());
	}

	static make(sequence core:Array[#T]) MinBinaryHeap[#T] {
		return new(sequence = sequence);
	}

	static heapProperty(sequence core:Array[#T]) Boolean {
		return true;
	}

	static zLeftChild(index Int) Int {
		return index * 2;
	}
	static zRightChild(index Int) Int {
		return (index * 2) + 1;
	}
	static zParent(index Int) Int {
		return index / 2;
	}

	static bubbleUp(list core:Array[#T], index Int) core:Array[#T] {
		if index == 0 {
			return list;
		}

		var parentIndex Int = MinBinaryHeap[#T].zParent(index);

		if list.get(index) < list.get(parentIndex) {
			return MinBinaryHeap[#T].bubbleUp(list.swap(index, parentIndex), parentIndex);
		}
		return list;
	}

	static bubbleDown(list core:Array[#T], index Int) core:Array[#T] {
		var a Int = MinBinaryHeap[#T].zLeftChild(index);
		var b Int = MinBinaryHeap[#T].zRightChild(index);
		if (list.size() - 1) < a {
			return list;
		} elseif (list.size() - 1) < b {
			if list.get(a) < list.get(index) {
				return MinBinaryHeap[#T].bubbleDown(list.swap(index, a), a);
			}
			return list;
		}

		if list.get(a) < list.get(b) {
			if list.get(a) < list.get(index) {
				return MinBinaryHeap[#T].bubbleDown(list.swap(index, a), a);
			}
			return list;
		} else {
			if list.get(b) < list.get(index) {
				return MinBinaryHeap[#T].bubbleDown(list.swap(index, b), b);
			}
			return list;
		}
	}

	method insert(value #T) MinBinaryHeap[#T] {
		var modified core:Array[#T] = this.sequence.append(value);
		modified = MinBinaryHeap[#T].bubbleUp(modified, 0); //modified.size().minus(1));
		return MinBinaryHeap[#T].make(modified);
	}

	method remove() MinBinaryHeap[#T], #T {
		return MinBinaryHeap[#T].make(MinBinaryHeap[#T].bubbleDown(this.sequence.swap(0, this.sequence.size()-1), 0)), this.sequence.get(0);
	}
}

interface Orderable[#T] {
	// RETURNS true when this is smaller than other in this ordering.
	method lessThan(other #T) Boolean;
}

class N is Orderable[N] {
	var value Int;

	static make(value Int) N {
		return new(value = value);
	}

	method lessThan(other N) Boolean {
		return this.value.lessThan(other.value);
	}

	// RETURNS the value this represents
	method get() Int {
		return this.value;
	}
}

class Test {
	static main!() Unit {
		var heap MinBinaryHeap[N] = MinBinaryHeap[N].makeEmpty();
		heap = heap.insert(N.make(7));
		heap = heap.insert(N.make(4));
		heap = heap.insert(N.make(3));
		heap = heap.insert(N.make(6));
		heap = heap.insert(N.make(5));
		heap = heap.insert(N.make(2));
		heap = heap.insert(N.make(1));

		var element N = N.make(1);

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));

		heap, element = heap.remove();
		do core:Out.println!(core:ASCII.formatInt(element.get()));
	}
}
