package test;
import core;

union Option[#T] {
	var some #T;
	var none Unit;

	static makeSome(value #T) Option[#T] {
		return new(some = value);
	}

	static makeNone() Option[#T] {
		return new(none = unit);
	}
}

class MinBinaryHeap[#T | #T is Orderable[#T]] {
	var sequence core:Array[#T];

	static makeEmpty() MinBinaryHeap[#T] {
		return new(sequence = core:Array[#T].make());
	}

	static make(sequence core:Array[#T]) MinBinaryHeap[#T] {
		return new(sequence = sequence);
	}

	static heapProperty(sequence core:Array[#T]) Boolean {
		return true;
	}

	static bubbleUp(list core:Array[#T], index Int) core:Array[#T] {
		var parent Int = 0; //index.divide(2);
		if list.get(index).lessThan(list.get(parent)) {
			return MinBinaryHeap[#T].bubbleUp(list.swap(index, parent), parent);
		}
		return list;
	}

	method insert(value #T) MinBinaryHeap[#T] {
		var modified core:Array[#T] = this.sequence.append(value);
		modified = MinBinaryHeap[#T].bubbleUp(modified, 0); //modified.size().minus(1));
		return MinBinaryHeap[#T].make(modified);
	}
}

interface Orderable[#T] {
	// RETURNS true when this is smaller than other in this ordering.
	method lessThan(other #T) Boolean;
}

class N is Orderable[N] {
	var value Int;

	static make(value Int) N {
		return new(value = value);
	}

	method lessThan(other N) Boolean {
		return this.value.lessThan(other.value);
	}
}

class Test {
	static main!() Unit {
		var heap MinBinaryHeap[N] = MinBinaryHeap[N].makeEmpty();

		do core:Out.println!(core:ASCII.formatInt(1));
		do core:Out.println!(core:ASCII.formatInt(2));
		do core:Out.println!(core:ASCII.formatInt(3));
		do core:Out.println!(core:ASCII.formatInt(4));
	}
}
