package test;
import core;

union Option[#T] {
	var some #T;
	var none Unit;

	static makeSome(value #T) Option[#T] {
		return new(some = value);
	}

	static makeNone() Option[#T] {
		return new(none = unit);
	}
}

class MinHeap[#T | #T is Orderable[#T]] {
	var sequence core:Array[#T];

	static make() MinHeap[#T] {
		return new(sequence = core:Array[#T].make());
	}

	static makeArray(sequence core:Array[#T]) MinHeap[#T] {
		return new(sequence = sequence);
	}

	static bubbleUp(list core:Array[#T], index Int) core:Array[#T] {
		if index == 0 {
			return list;
		}

		var parent Int = index.divide(2);
		if list.get(index).lessThan(list.get(parent)) {
			return MinHeap[#T].bubbleUp(list.swap(index, parent), parent);
		}
		return list;
	}

	method insert(value #T) MinHeap[#T] {
		var modified core:Array[#T] = this.sequence.append(value);
		modified = MinHeap[#T].bubbleUp(modified, modified.size().minus(1));
		return MinHeap[#T].makeArray(modified);
	}
}

interface Orderable[#T] {
	// RETURNS true when this is smaller than other in this ordering.
	method lessThan(other #T) Boolean;
}

class N is Orderable[N] {
	var value Int;

	static make(value Int) N {
		return new(value = value);
	}

	method lessThan(other N) Boolean {
		return this.value.lessThan(other.value);
	}
}

class Test {
	static main!() Unit {
		do core:Out.println!(core:ASCII.formatInt(1));
		do core:Out.println!(core:ASCII.formatInt(2));
		do core:Out.println!(core:ASCII.formatInt(3));
		do core:Out.println!(core:ASCII.formatInt(4));
	}
}
